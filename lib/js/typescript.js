'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _compilerBase = require('../compiler-base');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _sorcery = require('sorcery');

var _sorcery2 = _interopRequireDefault(_sorcery);

var _jsStringEscape = require('js-string-escape');

var _jsStringEscape2 = _interopRequireDefault(_jsStringEscape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const inputMimeTypes = ['text/typescript', 'text/tsx'];
const d = require('debug')('electron-compile:typescript-compiler');

let ts = null;
let istanbul = null;

const builtinKeys = ['hotModuleReload', 'coverage', 'babel'];

class TypeScriptCompiler extends _compilerBase.SimpleCompilerBase {
  constructor() {
    super();

    this.outMimeType = 'application/javascript';
    this.compilerOptions = {
      inlineSourceMap: true,
      inlineSources: true
    };
  }

  static getInputMimeTypes() {
    return inputMimeTypes;
  }

  _getParsedConfigOptions(tsCompiler) {
    let parsedConfig = this.parsedConfig;

    if (!parsedConfig) {
      let opts = Object.assign({}, this.compilerOptions);
      let builtinOpts = {};
      builtinKeys.forEach(k => {
        if (k in this.compilerOptions) {
          delete opts[k];
          builtinOpts[k] = this.compilerOptions[k];
        }
      });

      const results = tsCompiler.convertCompilerOptionsFromJson(opts);

      if (results.errors && results.errors.length) {
        throw new Error(JSON.stringify(results.errors));
      }

      parsedConfig = this.parsedConfig = { typescriptOpts: results.options, builtinOpts };
    }

    return parsedConfig;
  }

  compileSync(sourceCode, filePath) {
    ts = ts || require('typescript');
    const options = this._getParsedConfigOptions(ts);

    const isTsx = filePath.match(/\.tsx$/i);
    const transpileOptions = {
      compilerOptions: options.typescriptOpts,
      fileName: filePath.match(/\.(ts|tsx)$/i) ? _path2.default.basename(filePath) : null
    };

    if (isTsx && options.builtinOpts.hotModuleReload !== false) {
      sourceCode = this.addHotModuleLoadingRegistration(sourceCode, filePath, this.getExportsForFile(sourceCode, filePath, options.typescriptOpts));
    }

    let output = ts.transpileModule(sourceCode, transpileOptions);
    let sourceMaps = output.sourceMapText ? output.sourceMapText : null;
    if (options.builtinOpts.coverage) {
      sourceMaps = null;
      istanbul = istanbul || require('istanbul');

      sourceMaps = null;
      output.outputText = new istanbul.Instrumenter().instrumentSync(output.outputText, filePath);
    }

    d(JSON.stringify(output.diagnostics));

    const babelOpts = this.parsedConfig.builtinOpts.babel;
    if (babelOpts) {
      if (!this.babel) {
        const BabelCompiler = require("./babel").default;
        this.babel = new BabelCompiler();
        this.babel.compilerOptions = babelOpts;
      }
      if (!this.sorcery) {
        this.sorcer = require("sorcery");
      }
      let tsOutputPath = filePath.replace(/.tsx?$/i, ".js");
      let babelOutputPath = filePath.replace(/.tsx?$/i, ".babel.js");

      output.outputText = output.outputText.replace(/\/\/# sourceMap.*/g, "");

      let babelOutput = this.babel.compileSync(output.outputText, tsOutputPath);
      let chain = _sorcery2.default.loadSync(babelOutputPath, {
        content: {
          [filePath]: sourceCode,
          [tsOutputPath]: output.outputText,
          [babelOutputPath]: babelOutput.code
        },
        sourcemaps: {
          [tsOutputPath]: JSON.parse(sourceMaps),
          [babelOutputPath]: JSON.parse(babelOutput.sourceMaps)
        }
      });
      let finalSourceMaps = chain.apply();
      let outputCode = babelOutput.code + "\n//# sourceMappingURL=" + finalSourceMaps.toUrl();

      // the only way to make sourceMaps usable seems to be to have
      // them inlined right now, see https://github.com/electron/electron-compile/issues/172#issuecomment-277146112
      return {
        code: outputCode,
        mimeType: babelOutput.mimeType
      };
    }

    return {
      code: output.outputText,
      mimeType: this.outMimeType,
      sourceMaps
    };
  }

  addHotModuleLoadingRegistration(sourceCode, fileName, exports) {
    if (exports.length < 1) return sourceCode;

    let registrations = exports.map(x => {
      let id = `${x}` == 'default' ? '(typeof _default !== \'undefined\' ? _default : exports.default)' : `${x}`;
      let name = `"${x}"`;
      return `__REACT_HOT_LOADER__.register(${id}, ${name}, __FILENAME__);\n`;
    });

    let tmpl = `
${sourceCode}

if (typeof __REACT_HOT_LOADER__ !== 'undefined') {
  const __FILENAME__ = "${(0, _jsStringEscape2.default)(fileName)}";
  ${registrations}
}`;

    return tmpl;
  }

  getExportsForFile(sourceCode, fileName, tsOptions) {
    let sourceFile = ts.createSourceFile(fileName, sourceCode, ts.ScriptTarget.ES6);
    let ret = [];

    // Walk the tree to search for classes
    let visit = node => {
      if (!this.isNodeExported(node)) return;

      if (node.kind === ts.SyntaxKind.ClassDeclaration || node.kind === ts.SyntaxKind.FunctionDeclaration) {
        ret.push(node.name.text);
      }
    };

    ts.forEachChild(sourceFile, visit);

    return ret;
  }

  isNodeExported(node) {
    return (node.flags & ts.NodeFlags.Export) !== 0 || node.parent && node.parent.kind === ts.SyntaxKind.SourceFile;
  }

  getCompilerVersion() {
    return require('typescript/package.json').version;
  }
}
exports.default = TypeScriptCompiler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9qcy90eXBlc2NyaXB0LmpzIl0sIm5hbWVzIjpbImlucHV0TWltZVR5cGVzIiwiZCIsInJlcXVpcmUiLCJ0cyIsImlzdGFuYnVsIiwiYnVpbHRpbktleXMiLCJUeXBlU2NyaXB0Q29tcGlsZXIiLCJjb25zdHJ1Y3RvciIsIm91dE1pbWVUeXBlIiwiY29tcGlsZXJPcHRpb25zIiwiaW5saW5lU291cmNlTWFwIiwiaW5saW5lU291cmNlcyIsImdldElucHV0TWltZVR5cGVzIiwiX2dldFBhcnNlZENvbmZpZ09wdGlvbnMiLCJ0c0NvbXBpbGVyIiwicGFyc2VkQ29uZmlnIiwib3B0cyIsIk9iamVjdCIsImFzc2lnbiIsImJ1aWx0aW5PcHRzIiwiZm9yRWFjaCIsImsiLCJyZXN1bHRzIiwiY29udmVydENvbXBpbGVyT3B0aW9uc0Zyb21Kc29uIiwiZXJyb3JzIiwibGVuZ3RoIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwidHlwZXNjcmlwdE9wdHMiLCJvcHRpb25zIiwiY29tcGlsZVN5bmMiLCJzb3VyY2VDb2RlIiwiZmlsZVBhdGgiLCJpc1RzeCIsIm1hdGNoIiwidHJhbnNwaWxlT3B0aW9ucyIsImZpbGVOYW1lIiwiYmFzZW5hbWUiLCJob3RNb2R1bGVSZWxvYWQiLCJhZGRIb3RNb2R1bGVMb2FkaW5nUmVnaXN0cmF0aW9uIiwiZ2V0RXhwb3J0c0ZvckZpbGUiLCJvdXRwdXQiLCJ0cmFuc3BpbGVNb2R1bGUiLCJzb3VyY2VNYXBzIiwic291cmNlTWFwVGV4dCIsImNvdmVyYWdlIiwib3V0cHV0VGV4dCIsIkluc3RydW1lbnRlciIsImluc3RydW1lbnRTeW5jIiwiZGlhZ25vc3RpY3MiLCJiYWJlbE9wdHMiLCJiYWJlbCIsIkJhYmVsQ29tcGlsZXIiLCJkZWZhdWx0Iiwic29yY2VyeSIsInNvcmNlciIsInRzT3V0cHV0UGF0aCIsInJlcGxhY2UiLCJiYWJlbE91dHB1dFBhdGgiLCJiYWJlbE91dHB1dCIsImNoYWluIiwibG9hZFN5bmMiLCJjb250ZW50IiwiY29kZSIsInNvdXJjZW1hcHMiLCJwYXJzZSIsImZpbmFsU291cmNlTWFwcyIsImFwcGx5Iiwib3V0cHV0Q29kZSIsInRvVXJsIiwibWltZVR5cGUiLCJleHBvcnRzIiwicmVnaXN0cmF0aW9ucyIsIm1hcCIsIngiLCJpZCIsIm5hbWUiLCJ0bXBsIiwidHNPcHRpb25zIiwic291cmNlRmlsZSIsImNyZWF0ZVNvdXJjZUZpbGUiLCJTY3JpcHRUYXJnZXQiLCJFUzYiLCJyZXQiLCJ2aXNpdCIsIm5vZGUiLCJpc05vZGVFeHBvcnRlZCIsImtpbmQiLCJTeW50YXhLaW5kIiwiQ2xhc3NEZWNsYXJhdGlvbiIsIkZ1bmN0aW9uRGVjbGFyYXRpb24iLCJwdXNoIiwidGV4dCIsImZvckVhY2hDaGlsZCIsImZsYWdzIiwiTm9kZUZsYWdzIiwiRXhwb3J0IiwicGFyZW50IiwiU291cmNlRmlsZSIsImdldENvbXBpbGVyVmVyc2lvbiIsInZlcnNpb24iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsTUFBTUEsaUJBQWlCLENBQUMsaUJBQUQsRUFBb0IsVUFBcEIsQ0FBdkI7QUFDQSxNQUFNQyxJQUFJQyxRQUFRLE9BQVIsRUFBaUIsc0NBQWpCLENBQVY7O0FBRUEsSUFBSUMsS0FBSyxJQUFUO0FBQ0EsSUFBSUMsV0FBVyxJQUFmOztBQUVBLE1BQU1DLGNBQWMsQ0FBQyxpQkFBRCxFQUFvQixVQUFwQixFQUFnQyxPQUFoQyxDQUFwQjs7QUFFZSxNQUFNQyxrQkFBTiwwQ0FBb0Q7QUFDakVDLGdCQUFjO0FBQ1o7O0FBRUEsU0FBS0MsV0FBTCxHQUFtQix3QkFBbkI7QUFDQSxTQUFLQyxlQUFMLEdBQXVCO0FBQ3JCQyx1QkFBaUIsSUFESTtBQUVyQkMscUJBQWU7QUFGTSxLQUF2QjtBQUlEOztBQUVELFNBQU9DLGlCQUFQLEdBQTJCO0FBQ3pCLFdBQU9aLGNBQVA7QUFDRDs7QUFFRGEsMEJBQXdCQyxVQUF4QixFQUFvQztBQUNsQyxRQUFJQyxl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RzZGLFNBQUgsQ0FBYUMsTUFBM0IsTUFBdUMsQ0FBdkMsSUFBNkNYLEtBQUtZLE1BQUwsSUFBZVosS0FBS1ksTUFBTCxDQUFZVixJQUFaLEtBQXFCckYsR0FBR3NGLFVBQUgsQ0FBY1UsVUFBdEc7QUFDRDs7QUFFREMsdUJBQXFCO0FBQ25CLFdBQU9sRyxRQUFRLHlCQUFSLEVBQW1DbUcsT0FBMUM7QUFDRDtBQTNKZ0U7a0JBQTlDL0Ysa0IiLCJmaWxlIjoidHlwZXNjcmlwdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7U2ltcGxlQ29tcGlsZXJCYXNlfSBmcm9tICcuLi9jb21waWxlci1iYXNlJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHNvcmNlcnkgZnJvbSAnc29yY2VyeSc7XG5pbXBvcnQganNFc2NhcGUgZnJvbSAnanMtc3RyaW5nLWVzY2FwZSc7XG5cbmNvbnN0IGlucHV0TWltZVR5cGVzID0gWyd0ZXh0L3R5cGVzY3JpcHQnLCAndGV4dC90c3gnXTtcbmNvbnN0IGQgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbGVjdHJvbi1jb21waWxlOnR5cGVzY3JpcHQtY29tcGlsZXInKTtcblxubGV0IHRzID0gbnVsbDtcbmxldCBpc3RhbmJ1bCA9IG51bGw7XG5cbmNvbnN0IGJ1aWx0aW5LZXlzID0gWydob3RNb2R1bGVSZWxvYWQnLCAnY292ZXJhZ2UnLCAnYmFiZWwnXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHlwZVNjcmlwdENvbXBpbGVyIGV4dGVuZHMgU2ltcGxlQ29tcGlsZXJCYXNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub3V0TWltZVR5cGUgPSAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc7XG4gICAgdGhpcy5jb21waWxlck9wdGlvbnMgPSB7XG4gICAgICBpbmxpbmVTb3VyY2VNYXA6IHRydWUsXG4gICAgICBpbmxpbmVTb3VyY2VzOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJbnB1dE1pbWVUeXBlcygpIHtcbiAgICByZXR1cm4gaW5wdXRNaW1lVHlwZXM7XG4gIH1cblxuICBfZ2V0UGFyc2VkQ29uZmlnT3B0aW9ucyh0c0NvbXBpbGVyKSB7XG4gICAgbGV0IHBhcnNlZENvbmZpZyA9IHRoaXMucGFyc2VkQ29uZmlnO1xuXG4gICAgaWYgKCFwYXJzZWRDb25maWcpIHtcbiAgICAgIGxldCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21waWxlck9wdGlvbnMpO1xuICAgICAgbGV0IGJ1aWx0aW5PcHRzID0ge307XG4gICAgICBidWlsdGluS2V5cy5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgIGlmIChrIGluIHRoaXMuY29tcGlsZXJPcHRpb25zKSB7XG4gICAgICAgICAgZGVsZXRlIG9wdHNba107XG4gICAgICAgICAgYnVpbHRpbk9wdHNba10gPSB0aGlzLmNvbXBpbGVyT3B0aW9uc1trXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB0c0NvbXBpbGVyLmNvbnZlcnRDb21waWxlck9wdGlvbnNGcm9tSnNvbihvcHRzKTtcblxuICAgICAgaWYgKHJlc3VsdHMuZXJyb3JzICYmIHJlc3VsdHMuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkocmVzdWx0cy5lcnJvcnMpKTtcbiAgICAgIH1cblxuICAgICAgcGFyc2VkQ29uZmlnID0gdGhpcy5wYXJzZWRDb25maWcgPSB7IHR5cGVzY3JpcHRPcHRzOiByZXN1bHRzLm9wdGlvbnMsIGJ1aWx0aW5PcHRzIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZENvbmZpZztcbiAgfVxuXG4gIGNvbXBpbGVTeW5jKHNvdXJjZUNvZGUsIGZpbGVQYXRoKSB7XG4gICAgdHMgPSB0cyB8fCByZXF1aXJlKCd0eXBlc2NyaXB0Jyk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2dldFBhcnNlZENvbmZpZ09wdGlvbnModHMpO1xuXG4gICAgY29uc3QgaXNUc3ggPSBmaWxlUGF0aC5tYXRjaCgvXFwudHN4JC9pKTtcbiAgICBjb25zdCB0cmFuc3BpbGVPcHRpb25zID0ge1xuICAgICAgY29tcGlsZXJPcHRpb25zOiBvcHRpb25zLnR5cGVzY3JpcHRPcHRzLFxuICAgICAgZmlsZU5hbWU6IGZpbGVQYXRoLm1hdGNoKC9cXC4odHN8dHN4KSQvaSkgPyBwYXRoLmJhc2VuYW1lKGZpbGVQYXRoKSA6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKGlzVHN4ICYmIG9wdGlvbnMuYnVpbHRpbk9wdHMuaG90TW9kdWxlUmVsb2FkICE9PSBmYWxzZSkge1xuICAgICAgc291cmNlQ29kZSA9IHRoaXMuYWRkSG90TW9kdWxlTG9hZGluZ1JlZ2lzdHJhdGlvbihzb3VyY2VDb2RlLCBmaWxlUGF0aCwgdGhpcy5nZXRFeHBvcnRzRm9yRmlsZShzb3VyY2VDb2RlLCBmaWxlUGF0aCwgb3B0aW9ucy50eXBlc2NyaXB0T3B0cykpO1xuICAgIH1cblxuICAgIGxldCBvdXRwdXQgPSB0cy50cmFuc3BpbGVNb2R1bGUoc291cmNlQ29kZSwgdHJhbnNwaWxlT3B0aW9ucyk7XG4gICAgbGV0IHNvdXJjZU1hcHMgPSBvdXRwdXQuc291cmNlTWFwVGV4dCA/IG91dHB1dC5zb3VyY2VNYXBUZXh0IDogbnVsbDtcbiAgICBpZiAob3B0aW9ucy5idWlsdGluT3B0cy5jb3ZlcmFnZSkge1xuICAgICAgc291cmNlTWFwcyA9IG51bGw7XG4gICAgICBpc3RhbmJ1bCA9IGlzdGFuYnVsIHx8IHJlcXVpcmUoJ2lzdGFuYnVsJyk7XG5cbiAgICAgIHNvdXJjZU1hcHMgPSBudWxsO1xuICAgICAgb3V0cHV0Lm91dHB1dFRleHQgPSAobmV3IGlzdGFuYnVsLkluc3RydW1lbnRlcigpKS5pbnN0cnVtZW50U3luYyhvdXRwdXQub3V0cHV0VGV4dCwgZmlsZVBhdGgpO1xuICAgIH1cblxuICAgIGQoSlNPTi5zdHJpbmdpZnkob3V0cHV0LmRpYWdub3N0aWNzKSk7XG5cbiAgICBjb25zdCBiYWJlbE9wdHMgPSB0aGlzLnBhcnNlZENvbmZpZy5idWlsdGluT3B0cy5iYWJlbDtcbiAgICBpZiAoYmFiZWxPcHRzKSB7XG4gICAgICBpZiAoIXRoaXMuYmFiZWwpIHtcbiAgICAgICAgY29uc3QgQmFiZWxDb21waWxlciA9IHJlcXVpcmUoXCIuL2JhYmVsXCIpLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMuYmFiZWwgPSBuZXcgQmFiZWxDb21waWxlcigpO1xuICAgICAgICB0aGlzLmJhYmVsLmNvbXBpbGVyT3B0aW9ucyA9IGJhYmVsT3B0cztcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zb3JjZXJ5KSB7XG4gICAgICAgIHRoaXMuc29yY2VyID0gcmVxdWlyZShcInNvcmNlcnlcIik7XG4gICAgICB9XG4gICAgICBsZXQgdHNPdXRwdXRQYXRoID0gZmlsZVBhdGgucmVwbGFjZSgvLnRzeD8kL2ksIFwiLmpzXCIpO1xuICAgICAgbGV0IGJhYmVsT3V0cHV0UGF0aCA9IGZpbGVQYXRoLnJlcGxhY2UoLy50c3g/JC9pLCBcIi5iYWJlbC5qc1wiKTtcblxuICAgICAgb3V0cHV0Lm91dHB1dFRleHQgPSBvdXRwdXQub3V0cHV0VGV4dC5yZXBsYWNlKC9cXC9cXC8jIHNvdXJjZU1hcC4qL2csIFwiXCIpO1xuXG4gICAgICBsZXQgYmFiZWxPdXRwdXQgPSB0aGlzLmJhYmVsLmNvbXBpbGVTeW5jKG91dHB1dC5vdXRwdXRUZXh0LCB0c091dHB1dFBhdGgpO1xuICAgICAgbGV0IGNoYWluID0gc29yY2VyeS5sb2FkU3luYyhiYWJlbE91dHB1dFBhdGgsIHtcbiAgICAgICAgY29udGVudDoge1xuICAgICAgICAgIFtmaWxlUGF0aF06IHNvdXJjZUNvZGUsXG4gICAgICAgICAgW3RzT3V0cHV0UGF0aF06IG91dHB1dC5vdXRwdXRUZXh0LFxuICAgICAgICAgIFtiYWJlbE91dHB1dFBhdGhdOiBiYWJlbE91dHB1dC5jb2RlLFxuICAgICAgICB9LFxuICAgICAgICBzb3VyY2VtYXBzOiB7XG4gICAgICAgICAgW3RzT3V0cHV0UGF0aF06IEpTT04ucGFyc2Uoc291cmNlTWFwcyksXG4gICAgICAgICAgW2JhYmVsT3V0cHV0UGF0aF06IEpTT04ucGFyc2UoYmFiZWxPdXRwdXQuc291cmNlTWFwcyksXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbGV0IGZpbmFsU291cmNlTWFwcyA9IGNoYWluLmFwcGx5KCk7XG4gICAgICBsZXQgb3V0cHV0Q29kZSA9IGJhYmVsT3V0cHV0LmNvZGUgKyBcIlxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVwiICsgZmluYWxTb3VyY2VNYXBzLnRvVXJsKCk7XG5cbiAgICAgIC8vIHRoZSBvbmx5IHdheSB0byBtYWtlIHNvdXJjZU1hcHMgdXNhYmxlIHNlZW1zIHRvIGJlIHRvIGhhdmVcbiAgICAgIC8vIHRoZW0gaW5saW5lZCByaWdodCBub3csIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24vZWxlY3Ryb24tY29tcGlsZS9pc3N1ZXMvMTcyI2lzc3VlY29tbWVudC0yNzcxNDYxMTJcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IG91dHB1dENvZGUsXG4gICAgICAgIG1pbWVUeXBlOiBiYWJlbE91dHB1dC5taW1lVHlwZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IG91dHB1dC5vdXRwdXRUZXh0LFxuICAgICAgbWltZVR5cGU6IHRoaXMub3V0TWltZVR5cGUsXG4gICAgICBzb3VyY2VNYXBzXG4gICAgfTtcbiAgfVxuXG4gIGFkZEhvdE1vZHVsZUxvYWRpbmdSZWdpc3RyYXRpb24oc291cmNlQ29kZSwgZmlsZU5hbWUsIGV4cG9ydHMpIHtcbiAgICBpZiAoZXhwb3J0cy5sZW5ndGggPCAxKSByZXR1cm4gc291cmNlQ29kZTtcblxuICAgIGxldCByZWdpc3RyYXRpb25zID0gZXhwb3J0cy5tYXAoeCA9PiB7XG4gICAgICBsZXQgaWQgPSBgJHt4fWAgPT0gJ2RlZmF1bHQnID8gJyh0eXBlb2YgX2RlZmF1bHQgIT09IFxcJ3VuZGVmaW5lZFxcJyA/IF9kZWZhdWx0IDogZXhwb3J0cy5kZWZhdWx0KScgOiBgJHt4fWBcbiAgICAgIGxldCBuYW1lID0gYFwiJHt4fVwiYFxuICAgICAgcmV0dXJuIGBfX1JFQUNUX0hPVF9MT0FERVJfXy5yZWdpc3Rlcigke2lkfSwgJHtuYW1lfSwgX19GSUxFTkFNRV9fKTtcXG5gXG4gICAgfSk7XG5cbiAgICBsZXQgdG1wbCA9IGBcbiR7c291cmNlQ29kZX1cblxuaWYgKHR5cGVvZiBfX1JFQUNUX0hPVF9MT0FERVJfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgY29uc3QgX19GSUxFTkFNRV9fID0gXCIke2pzRXNjYXBlKGZpbGVOYW1lKX1cIjtcbiAgJHtyZWdpc3RyYXRpb25zfVxufWA7XG5cbiAgICByZXR1cm4gdG1wbDtcbiAgfVxuXG4gIGdldEV4cG9ydHNGb3JGaWxlKHNvdXJjZUNvZGUsIGZpbGVOYW1lLCB0c09wdGlvbnMpIHtcbiAgICBsZXQgc291cmNlRmlsZSA9IHRzLmNyZWF0ZVNvdXJjZUZpbGUoZmlsZU5hbWUsIHNvdXJjZUNvZGUsIHRzLlNjcmlwdFRhcmdldC5FUzYpO1xuICAgIGxldCByZXQgPSBbXTtcblxuICAgIC8vIFdhbGsgdGhlIHRyZWUgdG8gc2VhcmNoIGZvciBjbGFzc2VzXG4gICAgbGV0IHZpc2l0ID0gKG5vZGUpID0+IHtcbiAgICAgIGlmICghdGhpcy5pc05vZGVFeHBvcnRlZChub2RlKSkgcmV0dXJuO1xuICAgICAgXG4gICAgICBpZiAobm9kZS5raW5kID09PSB0cy5TeW50YXhLaW5kLkNsYXNzRGVjbGFyYXRpb24gfHwgbm9kZS5raW5kID09PSB0cy5TeW50YXhLaW5kLkZ1bmN0aW9uRGVjbGFyYXRpb24pIHtcbiAgICAgICAgcmV0LnB1c2gobm9kZS5uYW1lLnRleHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0cy5mb3JFYWNoQ2hpbGQoc291cmNlRmlsZSwgdmlzaXQpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGlzTm9kZUV4cG9ydGVkKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUuZmxhZ3MgJiB0cy5Ob2RlRmxhZ3MuRXhwb3J0KSAhPT0gMCB8fCAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQua2luZCA9PT0gdHMuU3ludGF4S2luZC5Tb3VyY2VGaWxlKTtcbiAgfVxuXG4gIGdldENvbXBpbGVyVmVyc2lvbigpIHtcbiAgICByZXR1cm4gcmVxdWlyZSgndHlwZXNjcmlwdC9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuICB9XG59XG4iXX0=